# -*- coding: utf-8 -*-
"""Final Draft

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-8cl-63xOhppPpU9bMrHMfJYIw7tsOjx
"""

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import math
import cmath
import random
import statistics
from scipy import stats

"""# OscParams Class and Functions"""

#Allows for easier accessbility of oscillation parameters in code. Customizable.
class OscParams:
  '''
    Designed to make oscillation parameters more accessible in the code.

    th12, th23, th13 -- neutrino mixing angles, in degrees
    del_m21, del_m31 -- neutrino mass splittings in ev^2
    delta            -- delta cp should be inputted in multiples of pi

  '''
  
  def __init__(self,th12,th23,th13,del_m21,del_m31,del_m32,delta):
    self.th12 =     th12*(np.pi/180)                                   
    self.th13 =     th13*(np.pi/180)
    self.th23 =     th23*(np.pi/180)
    self.del_m21 =  del_m21
    self.del_m31 =  del_m31
    self.del_m32 =  del_m32
    self.delta =    delta
    
    self.U21   = (-np.sin(self.th12)*np.cos(self.th23))-(np.cos(self.th12)*np.sin(self.th23)*np.sin(self.th13))
    self.U22   = (np.cos(self.th12)*np.cos(self.th23))-(np.sin(self.th12)*np.sin(self.th23)*np.sin(self.th13))
    self.U23   = np.sin(self.th23)*np.cos(self.th13)

#Parameters obtained from Neutrino Oscillation Phenomenology --Stephen J Parke https://lss.fnal.gov/archive/2007/pub/fermilab-pub-07-767-t.pdf
#Based on the parameters from the NOvA Experiment

ParamsNO = OscParams(33.83315867,45,5.739170478,8e-5,2.7e-3,2.7e-3,3*np.pi/2)           
ParamsIO = OscParams(33.83315867,45,5.739170478,8e-5,-2.7e-3,-2.7e-3,3*np.pi/2)

ParamsAntiNO = OscParams(33.83315867,45,5.739170478,8e-5,2.7e-3,2.7e-3,3*np.pi/2)
ParamsAntiIO = OscParams(33.83315867,45,5.739170478,8e-5,-2.7e-3,-2.7e-3,3*np.pi/2)


a = 1/4000
L = 810
hbarc = 197

def count_runs(list1, list2):
  '''By comparing magnitude of the nth elements in two lists, counts the number of runs between lists--performing a "Runs Test"
  
  Parameters:
      list1 -- the first list to conduct Runs Test with
      list2 -- the second list to conduct Runs Test with 
    **note : the lists must have the same length**
  
  Returns:
      neg       -- integer
                   amount of times list1's nth element was larger than list2's
      pos       -- integer
                   amount of times list1's nth element was smaller than list2's
      compare   -- list 
                   comprised of 0's and 1's indicating which list's nth element was larger per element
      total_runs --integer
                   the total number of runs observed between lists
   '''
 
  neg = 0
  pos = 0
  total_runs = 1
  compare = []

  for i in range(len(list1)):
    if(list1[i]>list2[i]):
      compare.append(1)
      pos = pos+1
  
    elif(list1[i]<list2[i]):
      compare.append(0)
      neg = neg+1
    #
    #If the nth elements in two lists are equal, a "coin toss" will occur to decide whether it should be a plus or minus
    #
    elif(list1[i]==list2[i]):
      chance = random.randint(1,2)
      if(chance==1):
        compare.append(1)
        pos=pos+1
      elif(chance==2):
        compare.append(0)
        neg=neg+1

    
  for i in range(1, len(compare)):
    if(compare[i-1]!=compare[i]):
      total_runs = total_runs+1
    else:
      None
  
  return (neg, pos, compare, total_runs)

#.......................................................

def test_countruns():
  list1 = []
  list2 = []
  for i in range(0,10):
    list1.append(np.random.randint(0,10))
    list2.append(np.random.randint(0,10))
  neg,pos,compare,total_runs = count_runs(list1,list2)
  print('List1: {}'.format(list1))
  print('List2: {}'.format(list2))
  print("The number of times list1 was less than list2: {}".format(neg))
  print("The number of times list1 was bigger than list2: {}".format(pos))
  print("The total runs between the two lists was: {}".format(total_runs))

#test_countruns()

def HistEstimate(DataSet,Start,End,BinWidth):
  '''
  Creates a histogram estimate of a given function by averaging the function value for a specified number of bins

  Parameters:
    DataSet      -- list
                    The dataset to create a histogram estimate of 
    Start        -- integer
                    the index of the first element you would like to include in the approximation
    End          -- integer
                    the index of the last element you would like to include in the approximation
    BinWidth     -- integer
                    the width of the bins you want to sort your data into (number of values that the average is calculated over)

  Returns:
    avgcounts    --list
                   the number of counts the estimate histogram has per bin  
  '''
  avgcounts = []
  for i in np.arange(Start,End,BinWidth):
    sample = DataSet[i:i+10]
    avgsample = sum(sample)/len(sample)
    if(avgsample>=0):
      avgcounts.append(avgsample)
    else:
      avgcounts.append(0)
    
  return avgcounts

def chi2poisson(n, mu):
  '''
  Return the chi^2 comparison of a poisson random number n drawn from a parent
  poisson distrubion of mean mu. Formula follows from the Particle Data Group
  review of probability and statistics Eq. 40.16:

  https://pdg.lbl.gov/2020/reviews/rpp2020-rev-statistics.pdf

  Parameters:
    n  - integer or float
         Observed number of counts
    mu - float
         Mean of underlying poisson distribution n is potentially drawn from

  Returns:
    float - the chi^2 value comparising n counts to mean mu
  '''
  #
  # A little defensive programming. The math will fail for negative or zero
  # arguments so trap those before proceeding.
  #
  if (n<0.0) | (mu<=0.0):
    raise ValueError("Illegal values for counts n,mu=(%f,%f)"%(n,mu))
  chi2 = mu - n
  if (n>0.0):
    chi2 = chi2 + n*math.log(n/mu)
  return 2.0*chi2

#...............................................................................
def test_chi2poisson():
  '''
  Unit test for chi2poisson
  '''
  print('Should give 20: ',chi2poisson(0, 10.0 ))
  print('Should give ~1: ',chi2poisson(90,100.0))
  try:
      print(chi2poisson(1,  0.0 ))
  except:
      print('Throwing exception is correct behavior.')

# test_chi2poisson()

def Exp(a,b,c,d,E):
  '''
  Returns a Gaussian function that can model neutrino events at the NOvA far detector
  Parameters:
     a -- customizable parameter for Gaussian
     b -- customizable parameter for Gaussian
     c -- customizable parameter for Gaussian
     d -- customizable parameter for Gaussian
     E -- used for neutrino energy here; should be the variable on x-axis when plotting
  
  Returns:   
    exp -- float
           the value of the created function at the specified E value
  '''

  term = ((E-b)/c)
  exp = a*(np.exp(-(term)**2))+d
  return exp

#...................................................

def test_Exp():
  NumuTest = []
  EnergyTest = []

  for E in np.arange(0,20,0.1):
    SampleExp = Exp(120,1.9,.75,1,E) 
    NumuTest.append(SampleExp)
    EnergyTest.append(E)
  '''
  fig100, ax100 = plt.subplots()
  plt.plot(EnergyTest,NumuTest)
  plt.title('Events vs. Energy')
  plt.xlabel('Energy (GeV)')
  plt.ylabel('Events')
  plt.xlim(0,5)
  '''
  return EnergyTest,NumuTest


test_Exp()
EnergyTest = []
AntiNumuTest = []
HistEstimation = []
for E in np.arange(0,5,0.1):
  SampleExp = Exp(120,1.83,0.75,1,E)
  AntiNumuTest.append(SampleExp)
  EnergyTest.append(E)
  
  for i in range(round(SampleExp)):
    HistEstimation.append(E)

'''
#plt.plot(EnergyTest,AntiNumuTest)
plt.ylim(0,140)
plt.xlim(0,5)

plt.hist(HistEstimation,bins=np.arange(0,5,0.1))
plt.title(r'Binned $\overline{\nu}_\mu$  Event Estimate')
plt.xlabel('Energy(GeV)')
plt.ylabel(r'$\overline{\nu}_\mu$  Events')
'''

def PAtm(th23,th13,del31):
  '''
  Returns the atmopsheric oscillation (u->e) probability for neutrinos as described by Neutrino Oscillation Phenomenology by Stephen J Parke:

  https://lss.fnal.gov/archive/2007/pub/fermilab-pub-07-767-t.pdf

  Parameters:
    th23  - float
            neutrino mixing angle theta23
    th13  - float
            neutrino mixing angle theta13
    del31 - float
            (((del_m31)*L)/(4*E))*(1000/hbarc) 


  Returns:
    float - The atmospheric oscillation probability for neutrinos.
  '''

  sqrtpatm = np.sin(th23)*np.sin(2*th13)*((np.sin(del31-a*L))/(del31-a*L))*del31
  return sqrtpatm

#..........................................

def test_PAtm():
  '''Plots PAtm with respect to energy'''
  ProbAtm = []
  Energy = []
  for E in np.arange(0.1,5,0.01):
    if (E==0):
      E = 0.000001

    del31     = (((ParamsNO.del_m31)*L)/(4*E))*(1000/hbarc)
    del21     = (((ParamsNO.del_m21)*L)/(4*E))*(1000/hbarc)
    del32 = del31

    PA = PAtm(ParamsNO.th23,ParamsNO.th13,del31)
    ProbAtm.append(PA)
    Energy.append(E)
  plt.plot(Energy,ProbAtm)
  plt.xlabel('Energy (GeV)')
  plt.ylabel('Atmospheric Probability')
  plt.title('PAtm vs Energy')
  #plt.xlim(0,5,0.25)

#test_PAtm()

def PAtmAnti(th23,th13,del31):
  '''
  Returns the atmopsheric oscillation (u->e) probability for antineutrinos as described by Neutrino Oscillation Phenomenology by Stephen J Parke:

  https://lss.fnal.gov/archive/2007/pub/fermilab-pub-07-767-t.pdf

  Parameters:
    th23  - float
            neutrino mixing angle theta23
    th13  - float
            neutrino mixing angle theta13
    del31 - float
            (((del_m31)*L)/(4*E))*(1000/hbarc) 


  Returns:
    float - The atmospheric oscillation probability for antineutrinos.
  '''

  sqrtpatmanti = np.sin(ParamsAntiNO.th23)*np.sin(2*ParamsAntiNO.th13)*((np.sin(del31+(a*L)))/(del31+a*L))*del31
  return sqrtpatmanti

#..................

def test_PAtmAnti():
  
  '''Plots PAtmAnti with respect to energy'''
 
  ProbAtmAnti = []
  Energy = []
  
  for E in np.arange(0.01,5,0.01):
    if (E==0):
      E = 0.000001

    del31     = (((ParamsNO.del_m31)*L)/(4*E))*(1000/hbarc)
    del21     = (((ParamsNO.del_m21)*L)/(4*E))*(1000/hbarc)
    del32 = del31

    PAA = PAtmAnti(ParamsNO.th23,ParamsNO.th13,del31)
    ProbAtmAnti.append(PAA)
    Energy.append(E)
  
  plt.plot(Energy,ProbAtmAnti)
  plt.xlabel('Energy (GeV)')
  plt.ylabel('Antineutrino Atmospheric Probability')
  plt.title('PAtmAnti vs Energy')
  plt.xlim(0,1)
  plt.ylim(0,0.1)

#test_PAtmAnti()

def PSol(th23,th12,del21):
  '''
   Returns the solar oscillation (u->e) probability for neutrinos and antineutrinos as described by Neutrino Oscillation Phenomenology by Stephen J Parke:

  https://lss.fnal.gov/archive/2007/pub/fermilab-pub-07-767-t.pdf

  Parameters:
    th23  - float
            neutrino mixing angle theta23
    th12  - float
            neutrino mixing angle theta12
    del21 - float
            (((del_m21)*L)/(4*E))*(1000/hbarc) 


  Returns:
    float - The solar oscillation probability for neutrinos and antineutrinos.
  '''
  sqrtpsol = np.cos(ParamsAntiNO.th23)*np.sin(2*ParamsAntiNO.th12)*((np.sin(a*L))/(a*L))*del21
  return sqrtpsol
  
def test_PSol():
  '''Plots PSol with respect to energy'''
  ProbSol = []
  Energy = []
  for E in np.arange(0.01,5,0.01):

    del31     = (((ParamsNO.del_m31)*L)/(4*E))*(1000/hbarc)
    del21     = (((ParamsNO.del_m21)*L)/(4*E))*(1000/hbarc)
    del32 = del31
    
    PS = PSol(ParamsNO.th23,ParamsNO.th12,del21)
  
    ProbSol.append(PS)
    Energy.append(E)
  plt.plot(Energy,ProbSol)
  plt.ylabel('Solar Probability')
  plt.xlabel('Energy (GeV)')
  plt.title('PSol vs. Energy')
  plt.xlim(0,5,0.25)
  plt.ylim(0,0.08)

#test_PSol()

def PInt(sqrtpatm, sqrtpsol, del32, delta):
  '''
 Returns the interference oscillation (u->e) probability for neutrinos as described by Neutrino Oscillation Phenomenology by Stephen J Parke:

  https://lss.fnal.gov/archive/2007/pub/fermilab-pub-07-767-t.pdf

  Parameters:
    sqrtpatm  - float
                the square root of the atmospheric oscillation probability for corresponding energy
    sqrtpsol  - float
                the square root of the solar oscillation probability for corresponding energy
    del32     - float
                (((del_m32)*L)/(4*E))*(1000/hbarc) 
    delta     - float (multiple of pi)
                CP-violating phase


  Returns:
    float - The interference oscillation probability for neutrinos.
  '''

  pint = 2*sqrtpatm*sqrtpsol*np.cos(del32+delta)
  return pint

def test_PInt():
  ProbInt = []
  Energy = []
  
  for E in np.arange(0.01,5,0.01):

    del31     = (((ParamsNO.del_m31)*L)/(4*E))*(1000/hbarc)
    del21     = (((ParamsNO.del_m21)*L)/(4*E))*(1000/hbarc)
    del32 = del31
    delta = np.pi/2
    
    PI = PInt(ParamsNO.th23,ParamsNO.th13,ParamsNO.th12,del31,del21,delta)
  
    ProbInt.append(PI)
    Energy.append(E)

  plt.plot(Energy,ProbInt)
  plt.ylabel('Interference Probability')
  plt.xlabel('Energy (GeV)')
  plt.title('PInt vs. Energy')
  plt.xlim(0,5,0.25)
  plt.ylim(0,0.01)


#test_PInt()

def PIntAnti(sqrtantipatm, sqrtantipsol, del32, delta):
  '''
   Returns the interference oscillation (u->e) probability for antineutrinos as described by Neutrino Oscillation Phenomenology by Stephen J Parke:

  https://lss.fnal.gov/archive/2007/pub/fermilab-pub-07-767-t.pdf

  Parameters:
    sqrtantipatm  - float
                    the square root of the atmospheric oscillation probability for corresponding energy
    sqrtantipsol  - float
                    the square root of the solar oscillation probability for corresponding energy
    del32         - float
                    (((del_m32)*L)/(4*E))*(1000/hbarc) 
    delta         - float (multiple of pi)  
                    CP-violating phase



  Returns:
    float - The interference oscillation probability for antineutrinos.
  '''
  #sqrtantipatm = np.sin(ParamsAntiNO.th23)*np.sin(2*ParamsAntiNO.th13)*((np.sin(del31+a*L))/(del31+a*L))*del31
  #sqrtantipsol = np.cos(ParamsAntiNO.th23)*np.sin(2*ParamsAntiNO.th12)*((np.sin(a*L))/(a*L))*del21
  
  pantiint = 2*sqrtantipatm*sqrtantipsol*np.cos(del32-delta)

  return pantiint

def test_PIntAnti():

  ProbIntAnti = []
  Energy = []
  
  for E in np.arange(0.01,5,0.01):

    del31     = (((ParamsNO.del_m31)*L)/(4*E))*(1000/hbarc)
    del21     = (((ParamsNO.del_m21)*L)/(4*E))*(1000/hbarc)
    del32 = 2.7e-3
    
    PIA = PIntAnti(ParamsAntiNO.th12,ParamsAntiNO.th23,ParamsAntiNO.th13,del21,del31,del31,(3/2)*np.pi)
  
    ProbIntAnti.append(PIA)
    Energy.append(E)
  
  plt.plot(Energy,ProbIntAnti)
  plt.xlim(0.2,1)
  plt.ylim(-0.01,0.01)
  plt.ylabel("Anti PInt")
  plt.xlabel("Energy (GeV)")
  plt.title("Anti Pint")
 

#test_PIntAnti()

"""# Oscillation Probabilities: Normal/Inverted, Neutrino/Antineutrino"""

#Normal Hierarchy Probabilities

Energy         = []

NormOscProb    = []  
AntiOscProb    = []

Numu = []                         #Gaussian estimate for Numu (before oscillations)
AntiNumu = []                     #Gaussian estimate for Nu Antimu (before oscillations)

for E in np.arange(0.1,20,0.01):
  
  Energy.append(E)


  del31     = (((ParamsNO.del_m31)*L)/(4*E))*(1000/hbarc)
  del21     = (((ParamsNO.del_m21)*L)/(4*E))*(1000/hbarc)
  del32     = del31

  invdel31  = (((ParamsIO.del_m31)*L)/(4*E))*(1000/hbarc)
  invdel32  = invdel31
  
  #Generating Numu/Antinumu
  numu = Exp(200,2.1,0.55,1,E) 
  Numu.append(numu)

  antinumu = Exp(150,2.1,0.55,1,E)
  AntiNumu.append(antinumu)

  #Generating Probabilities (Normal Neutrinos)

  sqrtpatm = PAtm(ParamsNO.th23, ParamsNO.th13,del31)
  
  sqrtpsol = PSol(ParamsNO.th23,ParamsNO.th12,del21)

  pint = PInt(sqrtpatm, sqrtpsol, del32, ParamsNO.delta) 

  #Generating Probabilities (Antineutrinos)

  sqrtantipatm = PAtmAnti(ParamsAntiNO.th23, ParamsAntiNO.th13, del31)
  
  pantiint = PIntAnti(sqrtantipatm, sqrtpsol, del32,ParamsNO.delta)

  NormOscProb.append(sqrtpatm**2+sqrtpsol**2+pint)
  AntiOscProb.append(sqrtantipatm**2+sqrtpsol**2+pantiint)
  

#Plot with just neutrino and antineutrinos
'''
fig1, ax1 = plt.subplots()
plt.plot(Energy,NormOscProb,color='blue',label = "Neutrinos")
plt.plot(Energy, AntiOscProb, color = 'red', label = 'Antineutrinos')


plt.xlim(0.185,10)
plt.ylim(0,0.1)
ax1.set_xscale('log')
ax1.set_xticks([0.5,1.0,2.0,5.0,10.0])
ax1.get_xaxis().set_major_formatter(matplotlib.ticker.ScalarFormatter())
plt.title("Atm + Solar + Interference (Normal Hierarchy)")
plt.xlabel("Energy (GeV)")
plt.ylabel("P(u->e)")
plt.legend(loc="upper right")

plt.ylim(0,0.1)
'''

# Inverse Hierarchy Probabilities

NormInvProb = []
AntiInvProb = []

for E in np.arange(0.1,20,0.01):
  
  del31     = (((ParamsAntiNO.del_m31)*L)/(4*E))*(1000/hbarc)
  del21     = (((ParamsAntiNO.del_m21)*L)/(4*E))*(1000/hbarc)
  del32     = del31

  invdel31 = (((-ParamsAntiNO.del_m31)*L)/(4*E))*(1000/hbarc)
  invdel32 = invdel31

  #Generating Probabilities (Neutrinos)
  sqrtinvpatm = PAtm(ParamsIO.th23, ParamsIO.th13, invdel31)
  
  sqrtinvpsol = PSol(ParamsIO.th23,ParamsIO.th12,del21)

  invpint = PInt(sqrtinvpatm, sqrtinvpsol, invdel32, ParamsIO.delta)

  
  #Generating Probabilities (Antineutrinos)
  
  sqrtinvantipatm = PAtmAnti(ParamsAntiIO.th23, ParamsAntiIO.th13, invdel31)

  pantiint = PIntAnti(sqrtinvantipatm, sqrtinvpsol, invdel32,3*np.pi/2)

  
  NormInvProb.append(sqrtinvpatm**2+sqrtinvpsol**2+invpint)
  AntiInvProb.append(sqrtinvantipatm**2+sqrtinvpsol**2+pantiint)

#Complete probability plot
'''
fig2, ax2 = plt.subplots()
plt.plot(Energy,NormOscProb, color = 'blue', label = 'Neutrinos - NO')
plt.plot(Energy,NormInvProb, color = 'blue', linestyle = 'dashed', label = "Neutrinos - IO")
plt.plot(Energy,AntiOscProb, color = 'lime', label = "Antineutrinos - NO")
plt.plot(Energy, AntiInvProb, color = 'lime', linestyle = "dashed", label = "Antineutrinos - IO")


ax2.set_xscale('log')
ax2.set_xticks([0.2,0.5,1.0,2.0,5.0,10.0])
ax2.get_xaxis().set_major_formatter(matplotlib.ticker.ScalarFormatter())
plt.xlim(0.22,10)     
plt.ylim(0,0.1)
plt.title("Oscillation Probabilities")
plt.xlabel("Energy (GeV)")
plt.ylabel(r'P($\nu_\mu -> \nu_e$) ')
plt.legend(loc="upper right")
'''

"""# Nu E Plot Generation (Normal Hierarchy)
w/ Generated Plot
"""

NuE = np.multiply(Numu, NormOscProb)
InvNuE = np.multiply(Numu, NormInvProb)

AntiNuE = np.multiply(AntiNumu, AntiOscProb)
InvAntiNuE = np.multiply(AntiNumu, AntiInvProb)

avgcountsNO = HistEstimate(NuE,0,1990,50)
avgbinsNO  = np.arange(0,20,0.5)
avgcountsIO = HistEstimate(InvNuE, 0, 1990, 50)

avgcountsantiNO = HistEstimate(AntiNuE,0,1990,50)
avgcountsantiIO = HistEstimate(InvAntiNuE, 0, 1990, 50)

#Scaling up Electron Neutrino Events 
ScaledNuE = np.multiply(5,NuE)
ScaledInvNuE = np.multiply(5,InvNuE)

ScaledAntiNuE = np.multiply(5,AntiNuE)
ScaledAntiInvNuE = np.multiply(5,InvAntiNuE)

HistNuE = []
HistInvNuE = []

HistAntiNuE = []
HistAntiInvNuE  = []

GeneratedDistribution = []

#avgcountsNO = HistEstimate(ScaledNuE,0,995,5)
#avgcountsIO = HistEstimate(ScaledInvNuE, 0, 995, 5)

#avgcountsantiNO = HistEstimate(ScaledAntiNuE,0,995,5)
#avgcountsantiIO = HistEstimate(ScaledAntiInvNuE, 0, 995, 5)


plt.plot(Energy, ScaledAntiNuE, color = 'blue', label = "Normal Ordering" )
plt.xlim(0,4)
plt.title(r'$\overline{\nu}_e$ Events vs. Energy')
plt.ylabel(r'$\overline{\nu}$ Events')
plt.xlabel("Energy (GeV)")
plt.ylim(0,35)

plt.plot(Energy, ScaledAntiInvNuE, color = 'red', label = "Inverted Ordering")
plt.legend(loc="upper right")

"""# Chi Square Calculations"""

#Running Chi Square between Normal and Inverted Hierarchies

trials = 1000

ChiSqDistCheck = []

FinalChiNorm = []
FinalChiInv = []

ChiSquareDiff = []
RunsDiff = []

for j in range(trials): 

  #Generated Distribution
  gencounts = []
  for i in range(len(avgcountsNO)):
    gencounts.append(np.random.poisson(avgcountsNO[i]))

  #Conducting Runs Tests

  Neg,Pos,notused,TotalRuns = count_runs(avgcountsNO,gencounts)

  NegInv,PosInv,notused,TotalInvRuns = count_runs(avgcountsIO,gencounts)

  TheoreticalValue =  (len(avgcountsNO)/2)+1

  numerator = 2*Neg*Pos*((2*Neg*Pos)-Neg-Pos)
  denominator = ((Neg+Pos)**2)*(Neg+Pos-1) 
  stdevNorm = np.sqrt(numerator/denominator)
  
  numeratorInv = 2*NegInv*PosInv*((2*NegInv*PosInv)-NegInv-PosInv)
  denominatorInv = ((NegInv+PosInv)**2)*(NegInv+PosInv-1)
  stdevInv = np.sqrt(numeratorInv/denominatorInv)

  ChiSqRuns = (TotalRuns-TheoreticalValue)**2/stdevNorm**2

  ChiSqInvRuns = (TotalInvRuns-TheoreticalValue)**2/stdevInv**2
  
  DifferenceRuns = ChiSqInvRuns-ChiSqRuns
  RunsDiff.append(DifferenceRuns)

  #Calculating Chi Square between Generated Dist && Normal/Inverted

  ChiNorm = []
  ChiInv  = []
  

  for i in range(len(avgcountsNO)):
    
      C_ValueNorm   = chi2poisson(gencounts[i], avgcountsNO[i])
      C_ValueInv    = chi2poisson(gencounts[i], avgcountsIO[i])
    

      ChiNorm.append(C_ValueNorm)
      ChiInv.append(C_ValueInv)

    #Checking Distribution
      ChiSqDistCheck.append(C_ValueNorm)
 
  NewTotalChiNorm = sum(ChiNorm)
  FinalChiNorm.append(NewTotalChiNorm)

  NewTotalChiInv = sum(ChiInv)
  FinalChiInv.append(NewTotalChiInv)
  
  
  ChiSquareDiff.append(NewTotalChiInv-NewTotalChiNorm)



print("The average Chi Square between data and normal ordering theory is: {}".format(sum(FinalChiNorm)/len(FinalChiNorm)))
uncertaintynorm = statistics.stdev(FinalChiNorm)/math.sqrt(len(FinalChiNorm))
print("The uncertainty in this measurement is: {}".format(uncertaintynorm))

print("The average Chi Square between data and inverted ordering theory is: {}".format(sum(FinalChiInv)/len(FinalChiInv)))
uncertaintyinv = statistics.stdev(FinalChiInv)/math.sqrt(len(FinalChiInv))
print("The uncertainty in this measurement is: {}".format(uncertaintyinv))

print("The average difference for Chi Square is: {}".format(sum(ChiSquareDiff)/len(ChiSquareDiff)))
totaluncertainty = uncertaintynorm + uncertaintyinv

#Running Chi Square between Normal and Inverted Hierarchies

trials = 1000


AntiChiSqDist  = []
AntiChiSqDistInv = []

FinalAntiChiNorm = []
FinalAntiChiInv = []

AntiDiffChiSquare = []

for j in range(trials): 

  #Generated Distribution
  gencounts = []
  for i in range(len(avgcountsantiNO)):
    gencounts.append(np.random.poisson(avgcountsantiNO[i]))

  
  #Calculating Chi Square between Generated Dist && Normal/Inverted

  AntiChiNorm = []
  AntiChiInv  = []
  AntiChiDiff = []

  for i in range(len(avgcountsantiNO)):

    C_ValueNorm   = chi2poisson(gencounts[i], avgcountsantiNO[i])
    C_ValueInv    = chi2poisson(gencounts[i], avgcountsantiIO[i])

    AntiChiNorm.append(C_ValueNorm)
    AntiChiInv.append(C_ValueInv)

 
  TotalChiNorm = sum(AntiChiNorm)
  TotalChiInv = sum(AntiChiInv)

  FinalAntiChiNorm.append(TotalChiNorm)
  FinalAntiChiInv.append(TotalChiInv)
  
  AntiDiffChiSquare.append(TotalChiInv-TotalChiNorm)

print("The average Chi Square between antineutrino simulation and normal ordering theory is: {}".format(sum(FinalAntiChiNorm)/len(FinalAntiChiNorm)))
uncertaintyantinorm = statistics.stdev(FinalAntiChiNorm)/math.sqrt(len(FinalAntiChiNorm))
print("The uncertainty in this measurement is: {}".format(uncertaintyinv))
print("The average Chi Square between antineutrino simulation and inverted ordering theory is: {}".format(sum(FinalAntiChiInv)/len(FinalAntiChiInv)))
uncertaintyantiinv = statistics.stdev(FinalAntiChiInv)/math.sqrt(len(FinalAntiChiInv))
print("The uncertainty in this measurement is: {}".format(uncertaintyantiinv))

print("The average difference for Chi Square is: {}".format(sum(AntiDiffChiSquare)/len(AntiDiffChiSquare)))

#Conclusion
print
NormalNOAverage = sum(FinalChiNorm)/len(FinalChiNorm)
NormalIOAverage = sum(FinalChiInv)/len(FinalChiInv)

AntiNOAverage = sum(FinalAntiChiNorm)/len(FinalAntiChiNorm)
AntiIOAverage = sum(FinalAntiChiInv)/len(FinalAntiChiInv)

totaluncertainty = uncertaintynorm + uncertaintyantinorm
totalinvuncertainty = uncertaintyinv + uncertaintyantiinv

print("The total chi square for the normal ordering is: {}".format(NormalNOAverage+AntiNOAverage))
print("The total uncertainty is: {}".format(totaluncertainty))
print("The total chi square for the inverted ordering is: {}".format(NormalIOAverage+AntiIOAverage))
print("The total uncertainty is: {}".format(totalinvuncertainty))
print("The total difference in chi square is: {}".format((sum(AntiDiffChiSquare)/len(AntiDiffChiSquare))+(sum(ChiSquareDiff)/len(ChiSquareDiff))))

print("The p-value for the chi-square is: {}".format(stats.chi2.pdf((NormalIOAverage+AntiIOAverage+totalinvuncertainty), len(avgcountsNO))))